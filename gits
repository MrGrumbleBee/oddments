#!/bin/zsh
die() { #{{{
    print $@
    exit 1
} #}}}
usage() {  #{{{
    cat << EOF
Usage: gits [options] DIRLIST -- WORD [git options]

    Where WORD is a git subcommand and DIRLIST is a list of directories.

OPTIONS:

  -c, --cols          Set number of terminal columns. (see below)
  -d, --debug         Debug output.
  -h, --help          Show usage, then exit.
  -r, --recurse       Recursively search DIRLIST for git repositories.
  -q, --quiet         Decrease verbosity by 1.
  -v, --verbose       Increase verbosity by 1.

  The effects of verbosity levels are described below:

     0    Suppress normal output.
     1    Identify and visually separate each repository.
     2    Slightly more verbose.

  Visual separators are the full column width of the terminal, unless overridden
  by --cols; if the terminal width is 0, as is the case for non-interactive
  shells, a default width of 64 is used.
EOF
exit
}
#}}}
process_options() { # {{{
    PARAMS=$(getopt -o c:dhrqv \
        --long cols:,debug,help,recurse,quiet::,verbose:: \
        -n $0 -- "$@")
    # Bail unless getopt returned 0
    [[ $? = 0 ]] || die Terminating...

    eval set -- ${PARAMS}
    while true; do
        case ${1} in
            -c | --cols)    COLS=$2;      shift 2;;
            -d | --debug)   DEBUG=true;   shift;;
            -r | --recurse) RECURSE=true; shift;;
            -h | --help)    usage;        shift;;

            -q)             let VERBOSE--; shift;;
            -v)             let VERBOSE++; shift;;
            --verbose)      case ${2} in
                            "") let VERBOSE++;      shift 2;;
                             *) let VERBOSE=${2};   shift 2;;
                            esac;;

            --) shift; break;;
             *) usage;;
        esac
    done
    GITARGS+=($@)
}
# }}}
opts_filter() { # Separate [options] from DIRLIST {{{
    local opt END=false
    for opt in $@; {
        [[ ${opt} == '--' ]] && END=true
        if ($END) {
            OPTARGS+=(${opt})
        } elif [[ -e ${opt} ]] {
            [[ -d ${opt} ]] && OPTDIRS+=(${opt:A})
        } else {
            OPTARGS+=(${opt})
        }
    }
}
# }}}
gits_filter() { # {{{
    [[ ${VERBOSE} > 1 ]] && print "Filtering repository list…"
    local d dir
    for d in $@; {
        [[ -d ${d} ]] || continue
        if (${RECURSE}) {
            [[ ${VERBOSE} > 1 ]] && print "    Searching ${d}"
            for dir in $(find ${d:A} -type d -name .git); {
                GITREPOS+=(${dir:h})
            }
        } else {
            [[ -d "${d}/.git" ]] && GITREPOS+=(${d:A})
        }
    }
    [[ ${VERBOSE} > 1 ]] && print ''
}
# }}}
if_remote() { # {{{
    if [[ -n $(git remote) ]] {
        git ${GITARGS[@]}
    } else {
        [[ ${VERBOSE} > 0 ]] && print 'No remote repository.'
    }
}
# }}}
gits_do() { # {{{
    [[ ${VERBOSE} > 1 ]] && print "Running git commands…\n"
    for GIT in ${GITREPOS[@]}; {
        cd ${GIT} || continue
        [[ ${VERBOSE} > 0 ]] && {
            typeset H; H=$(hostname -f)
            print -n "—⦗${H}:${PWD}⦘"
            repeat $(( ${COLS} - ${#PWD} - ${#H} - 3 )) print -n '—'
            print ''
        }
        case ${GITARGS[@]} in
            pu??) if_remote ${GITARGS[@]};;
           fetch) if_remote ${GITARGS[@]};;
               *) git ${GITARGS[@]};;
        esac
        [[ ${VERBOSE} > 0 ]] && {
            repeat ${COLS} print -n '—'
            print "\n"
        }
    }
}
# }}}
local DEBUG=false RECURSE=false VERBOSE=0 COLS=${COLUMNS}
local -a OPTDIRS OPTARGS GITREPOS GITARGS
[[ ${COLS} == 0 ]] && COLS=64 # non interactive default
if (($# < 2)) { usage } else { opts_filter $@ }
process_options ${OPTARGS[@]}
gits_filter ${OPTDIRS[@]}
[[ -z ${GITARGS} ]] && usage
${DEBUG} && {  # {{{
    print "  RECURSE: ${RECURSE}"
    print "  VERBOSE: ${VERBOSE}"
    print "  COLUMNS: ${COLS}"
    print "  GITARGS: ${GITARGS[@]}"
    print "  OPTARGS: ${OPTARGS[@]}"
    print "  OPTDIRS: ${#OPTDIRS}"
    print " GITREPOS: ${#GITREPOS}"
    print ''
}
# }}}
# Continue? (git sanity check)  # {{{
if [[ -z ${GITREPOS} &&  ${VERBOSE} > 0 ]] {
    print 'No git repositories found.'
}
# }}}
gits_do
